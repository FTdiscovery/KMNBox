from dfs import *
from kmnproof import *

def scoreMoves(board):
    availableMoves = board.availableMoves()
    scores = np.zeros(len(availableMoves))
    for i in range(len(availableMoves)):
        board.makeMove(availableMoves[i][0], availableMoves[i][1])
        boardstr = board.boardToString()
        if lookupstr(boardstr) != None:
            winner = int(2-(int(lookupstr(boardstr))+(dim[0]*dim[1]-boardstr.count('0')))%2)
            scores[i] = winner
        else:
            if board.gameOver():
                scores[i] = int((-0.5*board.gameWonBy())+1.5)
        board.plies -= 1
        board.setToZero(availableMoves[i][0], availableMoves[i][1])

    return scores

def immediatelyLosing(board):
    availableMoves = board.availableMoves()
    immediate = np.zeros(len(availableMoves))
    for i in range(len(availableMoves)):
        board.makeMove(availableMoves[i][0], availableMoves[i][1])
        if board.gameOver():
            immediate[i] = int((-0.5*board.gameWonBy())+1.5)
        board.plies -= 1
        board.setToZero(availableMoves[i][0], availableMoves[i][1])
    return immediate


def presentScores(moves, scores, immediate):
    for i in range(len(moves)):
        print("MOVE:", moves[i], "PLAYER WHO WINS:", scores[i], "IMMEDIATE WINNER:", immediate[i])

def player2AI(moves, scores):
    # we think the game ai will always have a winning move.
    possibleMoves = []
    for i in range(len(scores)):
        if scores[i]==2:
            possibleMoves.append(moves[i])
    # choose one of the good moves
    if len(possibleMoves)>0:
        return possibleMoves[np.random.randint(len(possibleMoves))]
    # thus this should never be invoked.
    return moves[0]

def player1AI(moves, scores, immediate):
    # we think the game ai will always have a losing move. so if it can find a winning move, play it!!
    possibleMoves = []
    for i in range(len(scores)):
        if scores[i]==1:
            possibleMoves.append(possibleMoves)
        elif immediate[i]==1:
            possibleMoves.append(possibleMoves)
    if len(possibleMoves)>0:
        return possibleMoves[np.random.randint(len(possibleMoves))]
    # if we haven't found anything yet, then just play a move that doesn't lose immediately
    for i in range(len(scores)):
        if scores[i]==0:
            possibleMoves.append(moves[i])
        elif immediate[i]==0:
            possibleMoves.append(moves[i])
    if len(possibleMoves)>0:
        return possibleMoves[np.random.randint(len(possibleMoves))]
    # if there is nothing left just admit defeat here
    return moves[0]




# Initialize the tablebase
loadlog()

# Initialize the board
state = KNBoard(dim[0], dim[1])

humanPlayer1 = True
humanPlayer2 = False
computerBattle = False
GENERATE_GAMES = 5  # used to see how many games should be generated by computer
freePlay = False

if freePlay:
    while not state.gameOver():

        # Print the board
        print(state.board)

        # Print the possible moevs
        presentScores(state.availableMoves(), scoreMoves(state), immediatelyLosing(state))

        row = int(input("----\n\nChoose Row: "))
        column = int(input("Choose Column: "))
        state.makeMove(row, column)

        print("-----")
if humanPlayer1:
    # Computer plays Player 2.
    while not state.gameOver():

        # Print the board
        print(state.board)

        # Print the possible moevs
        presentScores(state.availableMoves(), scoreMoves(state), immediatelyLosing(state))

        if state.plies % 2 == 0:
            row = int(input("----\n\nChoose Row: "))
            column = int(input("Choose Column: "))
            state.makeMove(row, column)
        else:
            aiMove = player2AI(state.availableMoves(), scoreMoves(state))
            print("AI CHOOSES: ", aiMove)
            state.makeMove(aiMove[0], aiMove[1])

        print("-----")
if humanPlayer2:
    # Computer plays Player 1.
    while not state.gameOver():

        # Print the board
        print(state.board)

        # Print the possible moevs
        presentScores(state.availableMoves(), scoreMoves(state), immediatelyLosing(state))

        if state.plies % 2 == 1:
            row = int(input("----\n\nChoose Row: "))
            column = int(input("Choose Column: "))
            state.makeMove(row, column)
        else:
            aiMove = player1AI(state.availableMoves(), scoreMoves(state), immediatelyLosing(state))
            print("AI CHOOSES: ", aiMove)
            state.makeMove(aiMove[0], aiMove[1])

        print("-----")
if computerBattle:
    # Computer plays both sides. This is theory.
    for i in range(GENERATE_GAMES):

        print("GAME", str(int(i+1)))
        # initialize board
        state = KNBoard(dim[0], dim[1])

        while not state.gameOver():

            # Print the board
            print(state.board)

            # Print the possible moves
            presentScores(state.availableMoves(), scoreMoves(state), immediatelyLosing(state))

            if state.plies % 2 == 0:
                aiMove = player1AI(state.availableMoves(), scoreMoves(state), immediatelyLosing(state))
                print("AI PLAYER 1 CHOOSES: ", aiMove)
                state.makeMove(aiMove[0], aiMove[1])
            else:
                aiMove = player2AI(state.availableMoves(), scoreMoves(state))
                print("AI PLAYER 2 CHOOSES: ", aiMove)
                state.makeMove(aiMove[0], aiMove[1])

            print("-----")

        print("Player", int(-0.5*state.gameWonBy()+1.5), "wins.")
        print("GAME OVER")


print(state.board)
print("PROGRAM OVER")
